/*
 * GoogleMapsPlatformLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.googleapis.maps.apis;

import com.googleapis.maps.ApiHelper;
import com.googleapis.maps.Server;
import com.googleapis.maps.exceptions.ApiException;
import com.googleapis.maps.exceptions.NearestRoadsErrorResponseException;
import com.googleapis.maps.http.request.HttpMethod;
import com.googleapis.maps.http.response.ApiResponse;
import com.googleapis.maps.models.NearestRoadsResponse;
import com.googleapis.maps.models.SnapToRoadsResponse;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import io.apimatic.coreinterfaces.http.request.ResponseClassType;
import java.io.IOException;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

/**
 * This class lists all the endpoints of the groups.
 */
public final class RoadsApi extends BaseApi {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public RoadsApi(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * This service returns the best-fit road geometry for a given set of GPS coordinates. This
     * service takes up to 100 GPS points collected along a route, and returns a similar set of data
     * with the points snapped to the most likely roads the vehicle was traveling along. Optionally,
     * you can request that the points be interpolated, resulting in a path that smoothly follows
     * the geometry of the road.
     * @param  path  Required parameter: The path to be snapped. The path parameter accepts a list
     *         of latitude/longitude pairs. Latitude and longitude values should be separated by
     *         commas. Coordinates should be separated by the pipe character: "|". For example:
     *         `path=60.170880,24.942795|60.170879,24.942796|60.170877,24.942796`. &lt;div
     *         class="note"&gt;Note: The snapping algorithm works best for points that are not too
     *         far apart. If you observe odd snapping behavior, try creating paths that have points
     *         closer together. To ensure the best snap-to-road quality, you should aim to provide
     *         paths on which consecutive pairs of points are within 300m of each other. This will
     *         also help in handling any isolated, long jumps between consecutive points caused by
     *         GPS signal loss, or noise.&lt;/div&gt;
     * @param  interpolate  Optional parameter: Whether to interpolate a path to include all points
     *         forming the full road-geometry. When true, additional interpolated points will also
     *         be returned, resulting in a path that smoothly follows the geometry of the road, even
     *         around corners and through tunnels. Interpolated paths will most likely contain more
     *         points than the original path. Defaults to `false`.
     * @return    Returns the SnapToRoadsResponse wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<SnapToRoadsResponse> snapToRoads(
            final List<String> path,
            final Boolean interpolate) throws ApiException, IOException {
        return prepareSnapToRoadsRequest(path, interpolate).execute();
    }

    /**
     * This service returns the best-fit road geometry for a given set of GPS coordinates. This
     * service takes up to 100 GPS points collected along a route, and returns a similar set of data
     * with the points snapped to the most likely roads the vehicle was traveling along. Optionally,
     * you can request that the points be interpolated, resulting in a path that smoothly follows
     * the geometry of the road.
     * @param  path  Required parameter: The path to be snapped. The path parameter accepts a list
     *         of latitude/longitude pairs. Latitude and longitude values should be separated by
     *         commas. Coordinates should be separated by the pipe character: "|". For example:
     *         `path=60.170880,24.942795|60.170879,24.942796|60.170877,24.942796`. &lt;div
     *         class="note"&gt;Note: The snapping algorithm works best for points that are not too
     *         far apart. If you observe odd snapping behavior, try creating paths that have points
     *         closer together. To ensure the best snap-to-road quality, you should aim to provide
     *         paths on which consecutive pairs of points are within 300m of each other. This will
     *         also help in handling any isolated, long jumps between consecutive points caused by
     *         GPS signal loss, or noise.&lt;/div&gt;
     * @param  interpolate  Optional parameter: Whether to interpolate a path to include all points
     *         forming the full road-geometry. When true, additional interpolated points will also
     *         be returned, resulting in a path that smoothly follows the geometry of the road, even
     *         around corners and through tunnels. Interpolated paths will most likely contain more
     *         points than the original path. Defaults to `false`.
     * @return    Returns the SnapToRoadsResponse wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<SnapToRoadsResponse>> snapToRoadsAsync(
            final List<String> path,
            final Boolean interpolate) {
        try {
            return prepareSnapToRoadsRequest(path, interpolate).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for snapToRoads.
     */
    private ApiCall<ApiResponse<SnapToRoadsResponse>, ApiException> prepareSnapToRoadsRequest(
            final List<String> path,
            final Boolean interpolate) {
        return new ApiCall.Builder<ApiResponse<SnapToRoadsResponse>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ROADS_APIS.value())
                        .path("/v1/snaptoroads")
                        .queryParam(param -> param.key("path")
                                .value(path))
                        .queryParam(param -> param.key("interpolate")
                                .value(interpolate).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("ApiKeyAuth"))
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, SnapToRoadsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This service returns individual road segments for a given set of GPS coordinates. This
     * services takes up to 100 GPS points and returns the closest road segments for each point. The
     * points passed do not need to be part of a continuous path.
     * @param  points  Required parameter: The points to be snapped. The points parameter accepts a
     *         list of latitude/longitude pairs. Separate latitude and longitude values with commas.
     *         Separate coordinates with the pipe character: "|". For example:
     *         `points=60.170880,24.942795|60.170879,24.942796|60.170877,24.942796`.
     * @return    Returns the NearestRoadsResponse wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<NearestRoadsResponse> nearestRoads(
            final List<String> points) throws ApiException, IOException {
        return prepareNearestRoadsRequest(points).execute();
    }

    /**
     * This service returns individual road segments for a given set of GPS coordinates. This
     * services takes up to 100 GPS points and returns the closest road segments for each point. The
     * points passed do not need to be part of a continuous path.
     * @param  points  Required parameter: The points to be snapped. The points parameter accepts a
     *         list of latitude/longitude pairs. Separate latitude and longitude values with commas.
     *         Separate coordinates with the pipe character: "|". For example:
     *         `points=60.170880,24.942795|60.170879,24.942796|60.170877,24.942796`.
     * @return    Returns the NearestRoadsResponse wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<NearestRoadsResponse>> nearestRoadsAsync(
            final List<String> points) {
        try {
            return prepareNearestRoadsRequest(points).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for nearestRoads.
     */
    private ApiCall<ApiResponse<NearestRoadsResponse>, ApiException> prepareNearestRoadsRequest(
            final List<String> points) {
        return new ApiCall.Builder<ApiResponse<NearestRoadsResponse>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ROADS_APIS.value())
                        .path("/v1/nearestRoads")
                        .queryParam(param -> param.key("points")
                                .value(points))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("ApiKeyAuth"))
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, NearestRoadsResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("400 BAD REQUEST",
                                (reason, context) -> new NearestRoadsErrorResponseException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}